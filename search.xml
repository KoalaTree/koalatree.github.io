<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode-169：Majority Element]]></title>
    <url>%2F2017%2F04%2F18%2FLeetCode-169_Majority_Element%2F</url>
    <content type="text"><![CDATA[QuestionGiven an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times. You may assume that the array is non-empty and the majority element always exist in the array. Idea给定一个大小为n的数组，找到其中的多数元素。其中的多数元素是超过n/2次重复的元素。 假定数组不为空，且多数数组始终存在与数组中。 idea1：由于这里假设数组不为空，且多数元素一定存在，该多数元素大于整个数组的n/2。步骤分为两步： 对数组进行排序，多数元素一定超过n/2个，所以一定会在该位置上出现； 该位置上的元素一定为多数元素，直接返回该元素。 idea2：Moore voting algorithm. 算法思想：每次都找出一对不同的元素，从数组中删掉，直到数组为空或只有一种元素； 不难证明，如果存在元素e出现频率超过半数，那么数组中最后剩下的就只有e。 idea3：一个更为直观的想法是，利用HashMap来实现每个元素与其个数一一对应，成为映射对。 相对idea1和idea2的时间消耗更大。 Code idea1—Java 123456public class Solution &#123; public int majorityElement(int[] nums) &#123; Arrays.sort(nums); return nums[nums.length/2]; &#125;&#125; 算法简单直接，时间复杂度低，Runtime：4ms. idea2—Java 1234567891011121314151617public class Solution &#123; public int majorityElement(int[] nums) &#123; int major = 0; int count = 0; for (Integer num:nums)&#123; if(count == 0)&#123; major = num; &#125; if(major != num)&#123; count--; &#125;else&#123; count++; &#125; &#125; return major; &#125;&#125; 在遍历过程中，当前元素与candidate相同则投支持票，否则投反对票。 当count状态为0时，说明之前的子数组中不存在重复次数超过一半的数，遍历余下的数组成为原问题的子问题。 若该数不一定存在，那么需要再一次遍历数组，鉴证找到的元素是否符合条件。 Moore 主页上有该问题的一个移步演示。 Runtime: 7ms。 idea3—Java 123456789101112131415161718public class Solution &#123; public int majorityElement(int[] nums) &#123; Map&lt;Integer,Integer&gt; myMap = new HashMap&lt;Integer, Integer&gt;(); int major = 0; for (Integer num:nums)&#123; if (!myMap.containsKey(num))&#123; myMap.put(num,1); &#125;else&#123; myMap.put(num,myMap.get(num)+1); &#125; if (myMap.get(num) &gt; nums.length/2)&#123; major = num; break; &#125; &#125; return major; &#125;&#125; 算法利用HashMap的containsKey()方法来判断一个元素是否已经添加其中； 如果元素不存在与HashMap中，则利用put()方法将对应的元素与其个数1组成键对放入其中； 如果元素存在，则对相应的元素对应的个数+1； 在整个循环中判断当前元素的个数是否大于n/2； 算法的时间复杂度高，Runtime：53ms。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-189：Rotate Array]]></title>
    <url>%2F2017%2F04%2F18%2FLeetCode-189_Rotate_Array%2F</url>
    <content type="text"><![CDATA[QuestionRotate an array of n elements to the right by k steps. For example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4]. Note:Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem. Idea将一个含有n个元素的数组，旋转k步，即将右边的k个元素，从数组尾部依次移动到数组的头部。 idea1:利用分步的思想，定义一个反转数组的函数，进行三次反转，进而得到目标数组. 首先进行原数组的整体反转； 将反转后的数组的当前k个元素进行反转； 再将后n-k个元素进行反转. Code idea1—Java 12345678910111213141516171819public class Solution &#123; public void rotate(int[] nums, int k) &#123; int n = nums.length; k = k%n; reverse(nums, 0, n-1); reverse(nums, 0, k-1); reverse(nums, k, n-1); &#125; public void reverse(int[] nums, int start, int end)&#123; while(start &lt; end)&#123; int temp = nums[start]; nums[start] = nums[end]; nums[end] = temp; start++; end--; &#125; &#125;&#125; 注意这里反转函数reverse()对数组操作，每次使用首尾一一对应的元素进行反转； 旋转数组注意k&gt;n的情况，一旦k=n，则相当于对数组不进行操作，故这里的k=k%n，取余数. Runtime：1ms. idea2 and idea3 有待提出.]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-219：Contains Duplicate II]]></title>
    <url>%2F2017%2F04%2F13%2FLeetCode-219_Contains_Duplicate_II%2F</url>
    <content type="text"><![CDATA[QuestionGiven an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k. Idea给定一个数组和一个整数k，找出数组中是否存在两个不同的索引i和j，使得nums[i]=num[j],并且要求i和j之间的绝对差值小于等于k. idea1:分析题目主要有两个要求，一个是找出数组中是否存在不同的i,j,有nums[i]=num[j]，有则返回true；一个是要求i和j的绝对值差&lt;=k。 nums[i]=num[j]的问题，可以利用HashSet来存储，因为HashSet中不存在重复的元素，一旦将重复元素添加如HashSet则操作会返回false; |i-j|&lt;=k的问题，可以利用滑动窗口的思想来解决，每次移动一个元素长度，当前在窗口中的元素添加入HashSet，不在窗口中的元素移出HashSet. Code idea1—Java 12345678910public class Solution &#123; public boolean containsNearbyDuplicate(int[] nums, int k) &#123; Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); for (int i=0; i&lt;nums.length; i++)&#123; if (i &gt; k) set.remove(nums[i-k-1]); if (!set.add(nums[i])) return true; &#125; return false; &#125;&#125; 一旦元素的索引i大于制定的k，则每次循环需要将大于k个距离的索引元素移出HashSet，使用其remove()方法； HashSet的add()方法，如果元素已经存在，则返回false； Runtime：18ms，beats:68.49%.]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-122：Best Time to Buy and Sell Stock II]]></title>
    <url>%2F2017%2F04%2F13%2FLeetCode-122_Best_Time_to_Buy_and_Sell_Stock_II%2F</url>
    <content type="text"><![CDATA[QuestionSay you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). Idea有一个数组，其中的元素是第i个元素是第i天股票的价格. 寻找在该数组给出的天数中的最大利润，可以进行多次购售。但是必须完成一次购售交易后才可进行下一次交易。 首先不同于Question 121：Best Time to Buy and Sell Stock,这次可以进行多次购售股票，可以进行多次交易，所以解题思路则可能会完全不同。 idea1：可以按照“121”的思路，但是需要在每次的购售之间加入入口标志和出口标志，最后返回几次购售最大值的总和。 算法较为复杂，易错，不是一个好的解决思路。 idea2：可以换一种思路，可以当天售出拥有的股票，然后再当天买入，以这种思想替代不卖出的举动。 只要后面的价格可以盈利，也就是相邻两天，后者大于前者，则当天进行两种操作，前一天买入，后一天卖出； 如果相邻的两天不能盈利，则不进行买卖。 对所有的元素进行两两依次遍历，保存所有盈利的和，进而简化了问题。 Code idea1—Java 1234567891011121314151617181920212223242526272829public class Solution &#123; public int maxProfit(int[] prices) &#123; if (prices == null || prices.length == 0) return 0; int max = 0; int total = 0; int buy = prices[0]; boolean flag = true; for (int i=1; i&lt;prices.length; ++i)&#123; if (flag == true &amp;&amp; prices[i] &lt; buy)&#123; buy = prices[i]; &#125;else if (flag == false &amp;&amp; prices[i] &lt; prices[i-1])&#123; flag = true; buy = prices[i]; total = total + max; max = 0; &#125;else&#123; flag = false; int profit = prices[i]-buy; if (max &lt; profit) max = profit; &#125; &#125; if (max == 0) return total; else return total + max; &#125;&#125; 需要设置一个flag来判断买入和卖出的条件； 注意当盈利为零的情况需要返回的值，以及正常非零的情况下需要返回的值； 在完成依次交易后，需要将flag置true,max置0。 Runtime：2ms，beats:11.98%. idea2—Java 12345678910111213public class Solution &#123; public int maxProfit(int[] prices) &#123; if (prices.length == 0) return 0; int profit=0; for (int i=0; i&lt;prices.length-1; i++)&#123; if (prices[i+1]-prices[i] &gt; 0)&#123; profit = profit + prices[i+1]-prices[i]; &#125; &#125; return profit; &#125;&#125; idea2明显要简单很多，易理解，易处理。 Runtime：2ms,和idea1相同。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-26：Remove Duplicates from Sorted Array]]></title>
    <url>%2F2017%2F04%2F13%2FLeetCode-26_Remove_Duplicates_from_Sorted_Array%2F</url>
    <content type="text"><![CDATA[QuestionGiven a sorted array, remove the duplicates in place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this in place with constant memory. For example,Given input array nums = [1,1,2], Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn’t matter what you leave beyond the new length. Idea给定一个已经排序后的数组，移除重复的元素，返回最终的数组的长度。 不能为另外一个数组分配额外的空间，必须使用常量内存完成。 已经排序过的数组，直接利用++i的操作来赋值给不同的元素进行操作就可以. 需要注意，仅需返回最终的数组的长度即可，无需关心在返回的长度之后还存在什么. Code ++i—Java 12345678910111213public class Solution &#123; public int removeDuplicates(int[] nums) &#123; if(nums.length == 0) return 0; int i = 0; for(int j=0; j&lt;nums.length; j++)&#123; if(nums[j] != nums[i])&#123; nums[++i] = nums[j]; &#125; &#125; return ++i; &#125;&#125; 最后注意，返回的是数组的长度，长度和索引相差1，故返回++i. Runtime：18ms，还有待提出其他算法来提高算法的运行算法.]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-66：Plus One]]></title>
    <url>%2F2017%2F04%2F13%2FLeetCode-66_Plus_One%2F</url>
    <content type="text"><![CDATA[QuestionGiven a non-negative integer represented as a non-empty array of digits, plus one to the integer. You may assume the integer do not contain any leading zero, except the number 0 itself. The digits are stored such that the most significant digit is at the head of the list. Idea利用一个非空的数组的数字来代表一个非负整数，为该整数加1. 假设该整数的前面没有0，最高有效位位于头部。 以十进制的加法规则进行加1则可。 从末位开始判断，当前位&lt;9则加1后直接返回数组，否则当前位置0，高位加1； 需要注意所有位均为9的情况。 Code 十进制加法规则—Java 123456789101112131415public class Solution &#123; public int[] plusOne(int[] digits) &#123; int n = digits.length; for (int i=n-1; i&gt;=0; i--)&#123; if(digits[i] &lt; 9)&#123; digits[i]++; return digits; &#125; digits[i] = 0; &#125; int[] newdigits = new int[n+1]; newdigits[0] = 1; return newdigits; &#125;&#125; 在所有位均为9的情况下，数组的大小不够需要增加一位空间，算法中直接创建一个新的数组； 这里利用了整型数组的默认值均为0，故只需将最高位置1，返回新数组即为原数组加1后的数组. Runtime：0ms.]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-121：Best Time to Buy and Sell Stock]]></title>
    <url>%2F2017%2F04%2F12%2FLeetCode-121_Best%20Time_to_Buy_and_Sell_Stock%2F</url>
    <content type="text"><![CDATA[QuestionSay you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit. Example 1:Input: [7, 1, 5, 3, 6, 4]Output: 5max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price) Example 2:Input: [7, 6, 4, 3, 1]Output: 0In this case, no transaction is done, i.e. max profit = 0. Idea给定一个数组，其中的第i个元素为第i天给出的股票价格，求出的一次购售利润。 对于这类问题，只需要对数组进行一次遍历，在遍历过程中记录利润，并在循环过程中保留最大利润即可。 Code 一次遍历—Java 1234567891011121314151617181920public class Solution &#123; public int maxProfit(int[] prices) &#123; if(prices == null || prices.length == 0)&#123; return 0; &#125; int buy = prices[0]; int max = 0; for (int i=0; i&lt;prices.length; i++)&#123; if (prices[i] &lt; buy)&#123; buy = prices[i]; &#125;else&#123; int profit = prices[i]-buy; if (max &lt; profit)&#123; max = profit; &#125; &#125; &#125; return max; &#125;&#125; 处理过程中，要考虑数组为null的情况； 这里在遍历的过程中，一旦遇到价格大于买入价格，就计算利润，保留最大利润，避免两次for循环。 Runtime:2ms.]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-268：Missing Number]]></title>
    <url>%2F2017%2F04%2F12%2FLeetCode-268_Missing_Number%2F</url>
    <content type="text"><![CDATA[QuestionGiven an array containing n distinct numbers taken from 0, 1, 2, …, n, find the one that is missing from the array. For example,Given nums = [0, 1, 3] return 2. Note:Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity? Idea给定一个含有n个不重复数字的数组，n个数字来自0, 1, 2, …, n, 找出其中丢失的数字。（这里并没有说明是按序排列的数组） Xor异或：由于b^b=0(这里是进行位异或)，所以a^b^b=a^0=a. 这里取a=0,依次与‘i’，‘nums[i]’进行异或运算. 如：a = a^0^0^1^1…^k^…n^n = a^k = 0^k = k. Sum求和：由于题目告诉只缺少一个数字，故用0~n的和减去数组的和得到的即为要求的数字. 0~n的和：n(n+1)/2. BinarySearch：将数组进行排序后，可以利用二分查找的方法来找到缺少的数字，不过对算法进行略微的改动. Code Xor异或—Java 123456789public class Solution &#123; public int missingNumber(int[] nums) &#123; int a = 0, i = 0; for (i=0; i&lt;nums.length;i++)&#123; a = a^i^nums[i]; &#125; return a^i; &#125;&#125; 算法中i从0~n-1(因为数组的大小为n),所以在循环结束后，i&lt;=nums[i]; 如果缺少的数字k&lt;n,则最后a^i以消去最后的nums[n-1]; 如果缺少的数字k=n,则最后a^i=i,刚好为缺少的数字n; 所以最后返回的值为a^i,这里注意i要设置为for循环外的变量。 时间复杂度低，Runtime：1ms. Sum求和—Java 12345678910public class Solution &#123; public int missingNumber(int[] nums) &#123; int n = nums.length; int sum = (n+0)*(n+1)/2; for (int i=0; i&lt;n; i++)&#123; sum -= nums[i]; &#125; return sum; &#125;&#125; 算法的时间复杂度为O(n),空间复杂度为O(1),Runtime：1ms. BinarySearch—Java 12345678910111213public class Solution &#123; public int missingNumber(int[] nums) &#123; Arrays.sort(nums); int low = 0; int high = nums.length; while (low &lt; high)&#123; int mid = (low+high)/2; if (nums[mid] &gt; mid) high = mid; else low = mid+1; &#125; return low; &#125;&#125; 算法这里有部分的变动,需要注意： high = nums.length,而不是nums.length-1,这里相当于high = n,因为搜索范围为0~n； 循环条件为low&lt;high,而不是low&lt;=high; 算法的时间复杂度较前两个要高，Runtime：15ms.]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-118：Pascal's Triangle]]></title>
    <url>%2F2017%2F04%2F11%2FLeetCode-118_Pascal's_Triangle%2F</url>
    <content type="text"><![CDATA[QuestionGiven numRows, generate the first numRows of Pascal’s triangle. For example, given numRows = 5,Return[ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] Idea给定行数，生成制定行数的Pascal’s triangle(又称，杨辉三角)。 直接使用Pascal三角的生成方式进行解题. Java： 使用ArrayList]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-119：Pascal's Triangle II]]></title>
    <url>%2F2017%2F04%2F11%2FLeetCode-119_Pascal's_Triangle_II%2F</url>
    <content type="text"><![CDATA[QuestionGiven an index k, return the kth row of the Pascal’s triangle. For example, given k = 3,Return [1,3,3,1]. Note:optimize your algorithm to use only O(k) extra space. Idea给定一个系数k，返回Pascal三角的第k行，将优化算法，使得算法的空间复杂度为O(k). 同LeetCode-118，直接使用Pascal三角的生成方式进行解题. 该题较118更为简单，无需要对Pascal三角的结构进行存储，仅需依次生成行至所需的行数即可； 使用ArrayList存储行. Code ArrayList—Java 123456789101112public class Solution &#123; public List&lt;Integer&gt; getRow(int rowIndex) &#123; ArrayList&lt;Integer&gt; row = new ArrayList&lt;Integer&gt;(); for (int i=0; i&lt;rowIndex+1; i++)&#123; row.add(0,1); for(int j=1; j&lt;row.size()-1;j++)&#123; row.set(j, row.get(j)+row.get(j+1)); &#125; &#125; return row; &#125;&#125; 虽然该题较118更为简单，但是依然需要注意，需要返回的是第k行，这里第0行为[1].]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-35：Search Insert Position]]></title>
    <url>%2F2017%2F04%2F11%2FLeetCode-35_Search_Insert_Position%2F</url>
    <content type="text"><![CDATA[QuestionGiven a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array. Here are few examples.[1,3,5,6], 5 → 2[1,3,5,6], 2 → 1[1,3,5,6], 7 → 4[1,3,5,6], 0 → 0 Idea给定一个已经排序的数组和目标值，存在，则返回目标值的索引；否则，返回应插入该数组的位置索引。 对于一个已经排序过的数组进行查找，则使用binary search较为常用。 Code Binary Search—Java 123456789101112public class Solution &#123; public int searchInsert(int[] nums, int target) &#123; int low = 0, high = nums.length-1; while(low &lt;= high)&#123; int mid = (low + high)/2; if (nums[mid] == target) return mid; else if (nums[mid] &gt; target) high = mid-1; else low = mid+1; &#125; return low; &#125;&#125; Java中，对于一个array，length是其属性，不是方法，使用：nums.length.]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
        <tag>BinarySearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简洁git笔记(三)]]></title>
    <url>%2F2017%2F03%2F06%2FAbstract_git_notes(3)%2F</url>
    <content type="text"><![CDATA[本次笔记主要关于git标签管理以及对于自定义git的学习。 六、标签管理发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。 Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。 tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。 1. 创建标签 在分支上创建标签—git tag &lt;name&gt; 切换到你想要创建标签的分支上 12345$ git branch* dev master$ git checkout masterSwitched to branch 'master' 在该分支上创建新的标签 1$ git tag v1.0 查看当前分支上的所有标签—git tag 12$ git tagv1.0 默认标签是打在最新提交的commit上的。 为遗漏掉的补打标签 查看历史提交的commit id 1234567891011$ git log --pretty=oneline --abbrev-commit6a5819e merged bug fix 101cc17032 fix bug 1017825a50 merge with no-ff6224937 add merge59bc1cb conflict fixed400b400 &amp; simple75a857c AND simplefec145a branch testd17efd8 remove test.txt... 如：对merge with no-ff这次提交打标签 1$ git tag v0.9 6224937 查看分支所有标签 123$ git tagv0.9v1.0 查看标签信息—git show &lt;tagname&gt; 1234567$ git show v0.9commit 1677e1acb7598d81766f21c051d0fe502b9bfd88Merge: 77be094 8238f43Author: KoalaTree &lt;631548343@qq.com&gt;Date: Wed Mar 1 20:31:36 2017 +0800 merge with no-ff 创建带有说明的标签 用-a指定标签名，-m指定说明文字 1$ git tag -a v0.1 -m "version 0.1 released" 3628164 查看标签说明 123456789101112$ git show v0.1tag v0.1Tagger: KoalaTree &lt;631548343@qq.com&gt;Date: Mon Mar 6 20:22:57 2017 +0800version 0.1 releasedcommit 2294c5323dbb2bd48ed6452bb6db03de4cb9cab4Author: KoalaTree &lt;631548343@qq.com&gt;Date: Thu Feb 23 14:50:12 2017 +0800 append GPL 通过-s用私钥签名一个标签 私钥签名创建标签 1$ git tag -s v0.2 -m "signed version 0.2 released" fec145a 签名采用PGP签名，因此，必须首先安装gpg（GnuPG），如果没有找到gpg，或者没有gpg密钥对，就会报错，如果报错，请参考GnuPG帮助文档配置Key。 用PGP签名的标签是不可伪造的，因为可以验证PGP签名。 2. 操作标签 删除标签—git tag -d &lt;tagname&gt; 12$ git tag -d v0.1Deleted tag 'v0.1' (was e078af9) 创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。 推送某个标签到远程—git push origin &lt;tagname&gt; 1234$ git push origin v1.0Total 0 (delta 0), reused 0 (delta 0)To https://github.com/KoalaTree/learngit.git * [new tag] v1.0 -&gt; v1.0 一次性推送全部未推送标签到远程—git push origin --tags 1234$ git push origin --tagsTotal 0 (delta 0), reused 0 (delta 0)To https://github.com/KoalaTree/learngit.git * [new tag] v0.9 -&gt; v0.9 删除远程标签 首先删除本地标签 12C:\git\learngit&gt;git tag -d v0.9Deleted tag 'v0.9' (was 1677e1a) 从远程删除。删除命令也是push 123C:\git\learngit&gt;git push origin :refs/tags/v0.9To https://github.com/KoalaTree/learngit.git - [deleted] v0.9 七、自定义git虽然在安装Git一节中，已经配置了user.name和user.email，实际上，Git还有很多可配置项。 如：让Git显示颜色，会让命令输出看起来更醒目1$ git config --global color.ui true 下面，我们进行学习git的配置以及其他自定义知识。 1. 忽略特殊文件有时必须把某些文件放到Git工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件等等，每次git status都会显示Untracked files …。 解决方法：在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。 不需要从头写.gitignore文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用。所有配置文件可以直接在线浏览GitHub官方的gitignore. 忽略文件的原则： * 忽略操作系统自动生成的文件，比如缩略图等； * 忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件； * 忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。 如在Windows下进行Python开发。如果有自定义目录，目录下就会有Desktop.ini文件。需要在 1234# Windows:Thumbs.dbehthumbs.dbDesktop.ini 继续忽略Python编译产生的.pyc、.pyo、dist等文件或目录 1234567# Python:*.py[cod]*.so*.egg*.egg-infodistbuild 加上自己定义的文件，最终得到一个完整的.gitignore文件 12345678910111213141516# Windows:Thumbs.dbehthumbs.dbDesktop.ini# Python:*.py[cod]*.so*.egg*.egg-infodistbuild# My configurations:db.inideploy_key_rsa 最后一步就是把.gitignore也提交到Git 2. 配置别名 简化命令输入 用git st替代git status： 1$ git config --global alias.st status 举例：用co表示checkout，ci表示commit，br表示branch 123$ git config --global alias.co checkout$ git config --global alias.ci commit$ git config --global alias.br branch 配置撤销修改别名 命令git reset HEAD file可以把暂存区的修改撤销掉（unstage），重新放回工作区，这里配置一个unstage别名。12$ git config --global alias.unstage 'reset HEAD'## git unstage test.py &lt;-----------&gt; git reset HEAD test.py 配置一个git last让其显示最后一次提交信息 1$ git config --global alias.last 'log -1' 这里git会报错，可以直接到gitconfig文件中，手动添加。 配置一个显示良好log的git lg1git config --global alias.lg "log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit" 效果图 3. 配置文件配置Git的时候，加上–global是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。 每个仓库的Git配置文件都放在.git/config文件中。 利用cat命令查看 12345678910111213141516C:\git\learngit&gt;cat .git/config[core] repositoryformatversion = 0 filemode = false bare = false logallrefupdates = true symlinks = false ignorecase = true[remote "origin"] url = https://github.com/KoalaTree/learngit.git fetch = +refs/heads/*:refs/remotes/origin/*[branch "master"] remote = origin merge = refs/heads/master[alias] last = log -1 别名就在[alias]后面，要删除别名，直接把对应的行删掉即可。 当前用户的Git配置文件放在用户主目录下的一个隐藏文件.gitconfig中(如我的是在C:\Users\V中)：123456789101112131415$ cat .gitconfig[user] name = KoalaTree email = 631548343@qq.com[filter "lfs"] clean = git-lfs clean %f smudge = git-lfs smudge %f required = true[color] ui = true[alias] st = status unstage = reset HEAD last = log -1 lg = log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit 配置别名也可以直接修改这个文件，如果改错了，可以删掉文件重新通过命令配置。 4. 搭建git服务器为保护商业性，在不愿意公开源码的时候，可以搭建属于自己的git服务器。 搭建Git服务器需要准备一台运行Linux的机器，推荐用Ubuntu或Debian，通过几条简单的apt命令就可以完成安装。 第零步：假设已经有sudo权限的用户账号。 第一步：安装git。 1$ sudo apt-get install git 第二步：创建一个git用户，用来运行git服务。 1$ sudo adduser git 第三步：创建证书登录。收集所有需要登录的用户的公钥，就是他们自己的id_rsa.pub文件，把所有公钥导入到/home/git/.ssh/authorized_keys文件里，一行一个。 第四步：初始化Git仓库。 选定一个目录作为Git仓库，假定是/srv/sample.git，在/srv目录下输入命令 1$ sudo git init --bare sample.git 此时，Git会创建一个裸仓库，没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以.git结尾。 然后，把owner改为git1$ sudo chown -R git:git sample.git 第五步: 禁用shell登录。 出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑/etc/passwd文件完成。 找到类似下面的一行: 12git:x:1001:1001:,,,:/home/git:/bin/bash## 改为 git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell git用户可以正常通过ssh使用git，但无法登录shell，因为我们为git用户指定的git-shell每次一登录就自动退出。 第六步，克隆远程仓库。 通过git clone命令克隆远程仓库123$ git clone git@server:/srv/sample.gitCloning into 'sample'...warning: You appear to have cloned an empty repository. 方便管理公钥，用Gitosis。 控制git权限，用Gitolite。 get more:《简洁git笔记(一)》《简洁git笔记(二)》]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>标签管理</tag>
        <tag>自定义git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简洁git笔记(二)]]></title>
    <url>%2F2017%2F03%2F01%2FAbstract_git_notes(2)%2F</url>
    <content type="text"><![CDATA[在简洁git笔记(一))中，我们主要学习了git版本库的创建以及仓库管理的相关命令，在以后的git使用中我们再也无须担心git仓库文件备份或者丢失的问题。 本篇继续学习git的其他功能。 四、远程仓库Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。 虽然我们完全可以自己搭建一台运行Git的服务器，不过现阶段，为了学Git而搭建服务器绝对是小题大作。目前GitHub 这个网站就为我们提供Git仓库托管服务，只要注册一个GitHub账号，就可以免费获得Git远程仓库。有关GitHub账号注册的方法，可以自行搜索方法。 由于我们自己本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，在此介绍一些相关设置。 创建SSH Key。在用户主目录下，查看是否有.ssh目录。如果有，则该目录下有没有id_rsa和id_rsa.pub这两个文件。若已有，可直接跳到下一步；若没有，打开Shell（Windows下打开Git Bash），创建SSH Key：1$ ssh-keygen -t rsa -C "youremail@example.com" #这里要把邮件地址换成你自己的邮件地址最后若一切顺利，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对。id_rsa是私钥，不能泄露出去；id_rsa.pub是公钥，可以放心地告诉任何人。 登陆GitHub，打开“settings”，“SSH Keys”页面，然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容。点“Add Key”，你就应该看到已经添加的Key。 为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。 GitHub允许添加多个Key。假定有若干电脑，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。 下面确保你拥有一个GitHub账号后，即将开始远程仓库的学习。 1. 添加远程库倘若已经在本地创建了一个Git仓库，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，可谓一举多得。 首先，登陆GitHub，然后点击“Repositories”，点击“New”按钮，开始创建一个新的仓库，这里我们创建learngit仓库，描述可自行填写。点击“Create repository”按钮，就成功地创建了一个新的Git仓库。 目前，在GitHub上的这个learngit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。 现在，我们根据GitHub的提示，在本地的learngit仓库下运行命令： 1$ git remote add origin https://github.com/KoalaTree/learngit.git #这里是我的GitHub上所提示的。要填写自己的GitHub连接。 添加后，Git默认远程库的名字就是origin，也可以改成别的，但origin一看就知道是远程库，故不建议做修改。 把本地库的所有内容推送到远程库上：12345678910$ git push -u origin masterCounting objects: 12, done.Delta compression using up to 4 threads.Compressing objects: 100% (8/8), done.Writing objects: 100% (12/12), 1.00 KiB | 0 bytes/s, done.Total 12 (delta 1), reused 0 (delta 0)remote: Resolving deltas: 100% (1/1), done.To https://github.com/KoalaTree/learngit.git * [new branch] master -&gt; masterBranch master set up to track remote branch master from origin. 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样： 从现在起，只要本地作了提交，就可以。通过命令：1$ git push origin master 把本地master分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库。 2. 从远程克隆那么如何将远程库克隆到本地库中？ 首先，登陆GitHub，创建一个新的仓库，名字叫gitskills：这里勾选Initialize this repository with a README，这样GitHub会自动为我们创建一个README.md文件。创建完毕后，可以看到README.md文件。 远程库已经准备好了，下一步是用命令git clone克隆一个本地库：12345$ git clone https://github.com/KoalaTree/gitskillsCloning into 'gitskills'...remote: Counting objects: 3, done.remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0Unpacking objects: 100% (3/3), done. 五、分支管理分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。 现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。 Git无论创建、切换和删除分支，Git在1秒钟之内就能完成！无论你的版本库是1个文件还是1万个文件。 1. 创建与合并每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。 一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点：2.每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长： 3. 当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上：Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！4. 从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变：5. 假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并：6. 合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支：7. 视频过程如下： 下面是整个过程的指令： 1.选择一个仓库，这里选择learngit，创建dev分支，并切换到dev分支—git checkout -b dev12$ git checkout -b devSwitched to a new branch 'dev' git checkout命令加上-b参数表示创建并切换，相当于以下两条命令：123$ git branch dev$ git checkout devSwitched to branch 'dev' 2.查看当前分支—git branch123$ git branch* dev master git branch命令会列出所有分支，当前分支前面会标一个*号。 3.在readme.txt加一行，并提交,如： 1Creating a new branch is quick. + 1234$ git add readme.txt $ git commit -m "branch test"[dev fec145a] branch test 1 file changed, 1 insertion(+) 4.dev分支工作完成，切换回master分支—git checkout master 1234$ git checkout masterD test.txtSwitched to branch 'master'Your branch is up-to-date with 'origin/master'. 5.切换回master分支后，再查看readme.txt文件，刚才添加的内容不见了！ 123$ cat readme.txtGit is a distributed version control system.Git is a free software distributed under the GPL. 因为那个提交是在dev分支上，而master分支此刻的提交点并没有变： 6.把dev分支的工作成果合并到master分支上—git merge dev12345$ git merge devUpdating 1096410..33b2bcbFast-forward readme.txt | 3 ++- 1 file changed, 2 insertions(+), 1 deletion(-) git merge命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的:1234C:\git\learngit&gt;cat readme.txtGit is a distributed version control system.Git is a free software distributed under the GPL.Creating a new branch is quick. 7.合并完成后，删除dev分支—git branch -d dev12$ git branch -d devDeleted branch dev (was fec145a). 删除后查看branch，就仅剩master分支了12$ git branch* master #因为创建、合并和删除分支非常快，所以鼓励使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。 2. 解决冲突 创建新的分支feature1，并切换当该分支上. 12$ git checkout -b feature1Switched to a new branch 'feature1' 修改readme.txt最后一行如下,并提交: 1Creating a new branch is quick AND simple. 切换到master分支上: 1234$ git checkout masterSwitched to branch 'master'Your branch is ahead of 'origin/master' by 1 commit. (use "git push" to publish your local commits) 这里git还会提示我们，当前master分支比远程的master分支要超前1个提交。 在master分支上把readme.txt文件最后行修改如下,并提交： 1Creating a new branch is quick &amp; simple. 当前master分支和feature1分支各自都分别有新的提交，如下： 这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突。 仍然尝试去提交： 1234$ git merge feature1Auto-merging readme.txtCONFLICT (content): Merge conflict in readme.txtAutomatic merge failed; fix conflicts and then commit the result. 这里便产生了冲突，git告诉我们readme.txt文件存在冲突，必须手动解决冲突后再提交。 git status也告诉我们冲突了12345678910$ git status# On branch master# Your branch is ahead of 'origin/master' by 2 commits.## Unmerged paths:# (use "git add/rm &lt;file&gt;..." as appropriate to mark resolution)## both modified: readme.txt#no changes added to commit (use "git add" and/or "git commit -a") 查看readme.txt的内容: 12345678$ cat readme.txtGit is a distributed version control system.Git is a free software distributed under the GPL.&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADCreating a new branch is quick &amp; simple.=======Creating a new branch is quick AND simple.&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1 这里Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容， 我们修改如下后保存,再进行提交：1Creating a new branch is quick and simple. 123$ git add readme.txt $ git commit -m "conflict fixed"[master 59bc1cb] conflict fixed 现在master分支和feature1分支变成了下图所示： 用带参数的git log也可以看到分支的合并情况: 12345678$ git log --graph --pretty=oneline --abbrev-commit* 59bc1cb conflict fixed|\| * 75a857c AND simple* | 400b400 &amp; simple|/* fec145a branch test... 最后删除feature1分支 3. 分支管理策略在合并分支时，Fast forward模式下，删除分支后，会丢掉分支信息。如果强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。--no-ff方式的git merge: 创建并切换dev分支,修改readme.txt内容后提交，并切换回master，在合并时使用--no-ff: 1234$ git merge --no-ff -m "merge with no-ff" devMerge made by the 'recursive' strategy. readme.txt | 1 + 1 file changed, 1 insertion(+) 本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。 合并后，我们用git log看看分支历史: 1234567$ git log --graph --pretty=oneline --abbrev-commit* 7825a50 merge with no-ff|\| * 6224937 add merge|/* 59bc1cb conflict fixed... 可以看到，不使用Fast forward模式，merge后就像这样: 分支策略 首先，master分支应是非常稳定的，仅用来发布新版本，平时不能在上面开发； 干活都在dev分支上，也就是说，dev分支是不稳定的。比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本； 在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。 团队合作的分支如： 4. Bug分支在修复bug的时候，工作只进行到一半，还没法提交。Git这里提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作。 如对readme.txt进行了修改，查看git状态： 12345678$ git status# On branch dev# Changes not staged for commit:# (use "git add &lt;file&gt;..." to update what will be committed)# (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)## modified: readme.txt# 分支暂时无法提交，但是必须在两个小时内修复该bug，怎么办？ “储藏”当前工作现场，等以后恢复现场后继续工作—git stash 123$ git stashSaved working directory and index state WIP on dev: 6224937 add mergeHEAD is now at 6224937 add merge 除非有其他没有管理的文件，否则现在git status查看工作区，就是干净的. 确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支 12345$ git checkout masterSwitched to branch 'master'Your branch is ahead of 'origin/master' by 6 commits.$ git checkout -b issue-101Switched to a new branch 'issue-101' 修复bug，如把“Git is a free software …”改为“Git is A free software …”，然后提交. 修复完成后，切换到master分支，并完成合并，最后删除issue-101分支. 1234$ git merge --no-ff -m "merged bug fix 101" issue-101Merge made by the 'recursive' strategy. readme.txt | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-) bug修复了，第二天回来继续工作，需要回到dev分支，工作区干净，调用git stash list： 12$ git stash liststash@&#123;0&#125;: WIP on dev: 6224937 add merge 恢复之前的工作区： 用git stash apply恢复指定的stash，但是恢复后，stash内容并不删除，需要用git stash drop来删除； 用git stash pop，恢复的同时把stash内容也删了。 5. Feature分支软件开发，总有无穷无尽的新的功能要不断添加进来。添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后合并，最后删除该feature分支。 开发代号为Vulcan的新功能： 12$ git checkout -b feature-vulcanSwitched to a new branch 'feature-vulcan' 开发完毕，将vulcan.py添加，并提交。 切回dev，准备合并。一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。然而，此时接到上级命令，因经费不足，新功能必须取消！这时切换分支回dev，删除feature-vulcan分支。 123$ git branch -d feature-vulcanerror: The branch 'feature-vulcan' is not fully merged.If you are sure you want to delete it, run 'git branch -D feature-vulcan'. Git友情提醒，feature-vulcan分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用命令git branch -D feature-vulcan。 则强行删除，删除成功。 6. 多人协作(1)远程库当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。 查看远程库的信息—git remote 12$ git remoteorigin 显示更详细的信息—git remote -v 123$ git remote -vorigin https://github.com/KoalaTree/learngit.git (fetch)origin https://github.com/KoalaTree/learngit.git (push) 上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址. (2)推送分支 把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上: 1$ git push origin master 并不是一定要把本地分支往远程推送。哪些分支需要推送，哪些不需要呢？ master分支是主分支，因此要时刻与远程同步； dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步； bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug； feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。 (3)抓取分支 模拟他人，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆： 1234567$ git clone https://github.com/KoalaTree/learngitCloning into 'learngit'...remote: Counting objects: 46, done.remote: Compressing objects: 100% (26/26), done.remote: Total 46 (delta 16), reused 45 (delta 15)Receiving objects: 100% (46/46), 15.69 KiB | 6 KiB/s, done.Resolving deltas: 100% (16/16), done. 他人从远程库clone时，默认情况下，他只能看到本地的master分支。 现在，他要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支： 1$ git checkout -b dev origin/dev 此后，他就可以在dev上继续修改，然后，时不时地把dev分支push到远程： 1234567891011$ git commit -m "add /usr/bin/env"[dev 291bea8] add /usr/bin/env 1 file changed, 1 insertion(+)$ git push origin devCounting objects: 5, done.Delta compression using up to 4 threads.Compressing objects: 100% (2/2), done.Writing objects: 100% (3/3), 349 bytes, done.Total 3 (delta 0), reused 0 (delta 0)To git@github.com:michaelliao/learngit.git fc38031..291bea8 dev -&gt; dev 他已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送： 123456789101112$ git add hello.py $ git commit -m "add coding: utf-8"[dev bd6ae48] add coding: utf-8 1 file changed, 1 insertion(+)$ git push origin devTo git@github.com:michaelliao/learngit.git ! [rejected] dev -&gt; dev (non-fast-forward)error: failed to push some refs to 'git@github.com:michaelliao/learngit.git'hint: Updates were rejected because the tip of your current branch is behindhint: its remote counterpart. Merge the remote changes (e.g. 'git pull')hint: before pushing again.hint: See the 'Note about fast-forwards' in 'git push --help' for details. 推送失败，因为他人的最新提交和你试图推送的提交有冲突。 解决办法也很简单，Git已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送。 12345678910111213141516$ git pullremote: Counting objects: 5, done.remote: Compressing objects: 100% (2/2), done.remote: Total 3 (delta 0), reused 3 (delta 0)Unpacking objects: 100% (3/3), done.From github.com:michaelliao/learngit fc38031..291bea8 dev -&gt; origin/devThere is no tracking information for the current branch.Please specify which branch you want to merge with.See git-pull(1) for details git pull &lt;remote&gt; &lt;branch&gt;If you wish to set tracking information for this branch you can do so with: git branch --set-upstream dev origin/&lt;branch&gt; git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接。 根据提示，设置dev和origin/dev的链接：根据提示，设置dev和origin/dev的链接： 12$ git branch --set-upstream dev origin/devBranch dev set up to track remote branch dev from origin. 完成后再进行pull: 1234$ git pullAuto-merging hello.pyCONFLICT (content): Merge conflict in hello.pyAutomatic merge failed; fix conflicts and then commit the result. git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样，解决后提交，再push到远端。 (4)多人协作工作模式 首先，可以试图用git push origin branch-name推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！ 如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令1git branch --set-upstream branch-name origin/branch-name get more:《简洁git笔记(一)》《简洁git笔记(三)》]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>远程仓库</tag>
        <tag>分支管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简洁git笔记(一)]]></title>
    <url>%2F2017%2F02%2F23%2FAbstract_git_notes(1)%2F</url>
    <content type="text"><![CDATA[目前世界上最先进的分布式版本控制系统–git. 一、git的安装和配置下载安装git 下载git for windows. 然后按默认选项安装即可。安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！ 配置你的git账户。12$ git config --global user.name "Your Name"$ git config --global user.email "email@example.com" 注意git config命令的--global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和email地址。 二、创建版本库版本库又名仓库(repository)，可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。 1. 版本库的创建 创建版本库目录1234$ mkdir learngit$ cd learngit$ pwd/git/learngit pwd命令用于显示当前目录。在我的电脑上，这个仓库位于/git/learngit。 创建版本库—git init12$ git initInitialized empty Git repository in C:/git/learngit/.git/ 自动生成的.git的目录是Git用来跟踪管理版本库的，不要手动修改这个目录里面的文件。可修改系统的隐藏文件查看选项来显示此文件。 2. 添加文件至版本库 如：编写一个readme.txt文件12Git is a version control system.Git is a free software. 注意一定要将它放到learngit目录下（其子目录下也可以）。 添加文件至仓库—git add 1$ git add readme.txt 提交文件至仓库—git commit 1234$ git commit -m "wrote a readme file"[master (root-commit) cb926e7] wrote a readme file 1 file changed, 2 insertions(+) create mode 100644 readme.txt git commit命令中-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。commit命令可以一次提交很多文件。 三、仓库管理1. 文件的修改 修改readme.txt文件 12Git is a distributed version control system.Git is a free software. 查看仓库当前状态—git status 123456789$ git statusOn branch masterChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: readme.txtno changes added to commit (use "git add" and/or "git commit -a") 上面的命令告诉我们，readme.txt被修改过了，但还没有准备提交的修改。 查看difference—git diff 12345678910$ git diff readme.txtdiff --git a/readme.txt b/readme.txtindex 0065b6f..0a30af0 100644--- a/readme.txt+++ b/readme.txt@@ -1,2 +1,2 @@-Git is a version control system.+Git is a distributed version control system. Git is a free software.\ No newline at end of file 添加并提交修改的文件 2. 版本回退 再次修改readme.txt文件 12Git is a distributed version control system.Git is a free software distributed under the GPL. 添加并提交 1234$ git add readme.txt$ git commit -m "append GPL"[master 3628164] append GPL 1 file changed, 1 insertion(+), 1 deletion(-) 目前共有三个版本的readme.txt版本1：wrote a readme file、版本2：add distributed、版本3：append GPL 查看历史记录—git log123456789101112131415161718$ git logcommit 2294c5323dbb2bd48ed6452bb6db03de4cb9cab4Author: KoalaTree &lt;631548343@qq.com&gt;Date: Thu Feb 23 14:50:12 2017 +0800 append GPLcommit 70ff885150a052e1b40ab6156a1154be76794938Author: KoalaTree &lt;631548343@qq.com&gt;Date: Thu Feb 23 14:41:21 2017 +0800 add distributedcommit 0700efaf2a0a1551f2086cfce5393ce0d1dff038Author: KoalaTree &lt;631548343@qq.com&gt;Date: Thu Feb 23 13:40:11 2017 +0800 wrote a readme file 加上--pretty=oneline参数可以减少输出信息1234$ git log --pretty=oneline2294c5323dbb2bd48ed6452bb6db03de4cb9cab4 append GPL70ff885150a052e1b40ab6156a1154be76794938 add distributed0700efaf2a0a1551f2086cfce5393ce0d1dff038 wrote a readme file 版本回退—git reset在Git中，用HEAD表示当前版本，也就是最新的提交的版本，上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。12$ git reset --hard "HEAD^" #注意win10的shell把^当做换行转义了, 类似与\，这里使用"包起来即可HEAD is now at 70ff885 add distributed 或者1$ git reset --hard HEAD~1 查看readme.txt内容版本—cat readme.txt 123$ cat readme.txtGit is a distributed version control system.Git is a free software. 再回到版本3在不关掉命令行窗口的条件下，找到append GPL的commit id，指定回到未来的某个版本： 12$ git reset --hard 2294c5323HEAD is now at 2294c53 append GPL 这里版本号没必要写全，前几位就可以了，Git会自动去找。 查看命令—git reflog如果关掉了命令窗口，可以通过该命令来查看版本id,凭此回到最新的版本。123456$ git reflog2294c53 HEAD@&#123;0&#125;: reset: moving to 2294c532370ff885 HEAD@&#123;1&#125;: reset: moving to HEAD~12294c53 HEAD@&#123;2&#125;: commit: append GPL70ff885 HEAD@&#123;3&#125;: commit: add distributed0700efa HEAD@&#123;4&#125;: commit (initial): wrote a readme file 3. 工作区和暂存区 工作区(Working Directory)就是电脑里能看到的目录，如当前learngit文件夹就是一个工作区。 版本库(Repository)工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。 添加和提交文件步骤第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。 创建新的文件LICENSE，将其与readme.txt添加git add 提交缓存区文件git commit 4. 撤销修改 在将文件git add到缓存区后，修改了文件如 1234$ cat readme.txtGit is a distributed version control system.Git is a free software.She is so beautiful. 利用git status查看状态 1234567891011121314151617$ git statusOn branch masterChanges to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) modified: readme.txtChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: readme.txtUntracked files: (use "git add &lt;file&gt;..." to include in what will be committed) git git提示我们可以使用命令来撤销工作区的修改—git checkout -- filename 1$ git checkout -- readme.txt 命令git checkout -- readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况：一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；一种是readme.txt已经添加到暂存区后，又作了修改，撤销修改就回到添加到暂存区后的状态。总之，就是让这个文件回到最近一次git commit或git add时的状态。 用命令git reset HEAD file可以把添加到暂存区的修改撤销掉(unstage)重新放回工作区。123$ git reset HEAD readme.txtUnstaged changes after reset:M readme.txt git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。 再用git status查看123456789$ git statusOn branch masterChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: readme.txtno changes added to commit (use "git add" and/or "git commit -a") 现在暂存区是干净的，工作区有修改。 最后利用git checkout -- readme.txt丢弃工作区的修改。123$ cat readme.txtGit is a distributed version control system.Git is a free software distributed under the GPL. 可见修改已经被丢弃，文件回到了当初的状态。 ##小结 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout – file。 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。 5. 删除文件 添加一个新文件test.txt到Git并且提交 12345$ git add test.txt$ git commit -m "add test.txt"[master 1096410] add test.txt 1 file changed, 1 insertion(+) create mode 100644 test.txt 在文件管理器中把无用的该文件删除，或者用rm命令删除 1$ rm test.txt 工作区和版本库一致，git status命令会立刻告诉你哪些文件被删除 1234567891011121314$ git statusOn branch masterChanges not staged for commit: (use "git add/rm &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) deleted: test.txtUntracked files: (use "git add &lt;file&gt;..." to include in what will be committed) gitno changes added to commit (use "git add" and/or "git commit -a") 若确实要从版本库中删除该文件—命令git rm删掉，并且git commit 123456$ git rm test.txtrm 'test.txt'$ git commit -m "remove test.txt"[master d17efd8] remove test.txt 1 file changed, 1 deletion(-) delete mode 100644 test.txt 若误删，把误删的文件恢复到最新版本 1$ git checkout -- test.txt get more:《简洁git笔记(二)》《简洁git笔记(三)》]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>git仓库</tag>
        <tag>仓库管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows10系统安装TensorFlow]]></title>
    <url>%2F2017%2F02%2F21%2FTensorFlow_for_win10_system%2F</url>
    <content type="text"><![CDATA[11月29日，Google Brain工程师团队宣布在 TensorFlow 0.12 中加入初步的Windows支持。 在谷歌的支持下，TensorFlow 已成为 GitHub 上最受欢迎的机器学习开源项目。同时，谷歌也在 TensorFlow 框架中进行过各类研究、开源了其中一些项目，这些研究涉及到自然语言处理、机器翻译、图像描述、图像分类等等。随着 TensorFlow r0.12 版的发布，这一开源软件库现已支持 Windows7、10 和 Server 2016。同时，这一新版本可以让用户在 TensorFlow 训练中得到 CUDA 8 的 GPU 加速。我们已将新版本在 PyPI 中封装成型。现在你可以使用命令‘pip install tensorflow’来安装 TensorFlow 了。 一、安装python和python-pip1. 下载安装python 下载python3.5.2 for windows10 AMD.##因为电脑是AMD显卡，所以3.5.2版本是我安装的版本，这个连接可以直接用下载工具下载。需要其他版本请到官网直接下载。 安装python并配置python的环境变量. 2. 下载安装python-pip 下载python-pip. 解压python-pip的安装包，进入到文件的目录中. 在这个文件夹按住Shift键单击鼠标右键-&gt;点击在此处打开命令窗口. 安装pip.在命令行执行如下命令。 1$ python setup.py install 配置python-pip的环境变量,(一般python安装完毕后便会配置成功)。Pip的安装路径在Python的安装路径下的Scripts里面，所以把Pip的路径添加到Path变量里面就可以了。 二、安装TensorFlow如果上面python和python-pip安装没有问题，只需要执行一个指令就可以顺利安装TensorFlow。 1C:&gt; pip install tensorflow Tensorflow所需要的依赖会自动安装： 三、你的第一个测试TensorFlow程序1. 测试代码输出hello123456$ pythonimport tensorflow as tfhello = tf.constant('Hello, TensorFlow!');sess = tf.Session();sess.run(hello);Hello, TensorFlow! 10+32=？123a = tf.constant(10)b = tf.constant(32)sess.run(a+b) 2. 输出成功结果 至此TensorFlow已经安装完毕，请尽情使用它吧！]]></content>
      <categories>
        <category>TensorFlow</category>
      </categories>
      <tags>
        <tag>TensorFlow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F02%2F20%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
